# DDD

Domain-Driven Design (DDD) - подход к проектированию, в котором архитектура
строится вокруг предметной области и общего языка команды.

## Когда DDD оправдан

- бизнес-правила сложные и часто меняются;
- один продукт покрывает несколько доменных областей;
- нужна независимая эволюция команд по границам контекстов.

## Ключевые элементы

- Ubiquitous Language: общий язык бизнеса и разработки.
- Bounded Context: четкая граница модели и терминов.
- Entity и Value Object: различение сущностей с идентичностью и объектов-значений.
- Aggregate: транзакционная граница согласованности.
- Domain Service: бизнес-операции, которые не принадлежат одной сущности.

## Пример контекстов

```kroki-plantuml
@startuml
left to right direction
package "Контекст Продажи" {
  [Order Aggregate]
  [Pricing Service]
}
package "Контекст Логистики" {
  [Shipment Aggregate]
}
package "Контекст Платежей" {
  [Payment Aggregate]
}

[Order Aggregate] --> [Payment Aggregate] : PaymentRequested
[Order Aggregate] --> [Shipment Aggregate] : ShipmentRequested
@enduml
```

## Как внедрять DDD

1. Выделите проблемный домен и ключевые бизнес-термины.
1. Разделите модель на bounded contexts и договоритесь о границах.
1. Для каждого контекста определите агрегаты и инварианты.
1. Зафиксируйте контракты взаимодействия между контекстами.

## Типичные ошибки

- попытка построить единую модель на всю компанию;
- смешение инфраструктурной и доменной логики;
- отсутствие владельцев bounded context.

## Чек-лист качества

- Границы контекстов отражены в коде и API-контрактах.
- Термины в требованиях и реализации совпадают.
- Инварианты агрегатов покрыты тестами.
