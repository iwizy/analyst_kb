# Клиент-серверная архитектура

Клиент-сервер — базовая модель взаимодействия, где клиент инициирует запрос, а сервер обрабатывает и возвращает результат.

## Уровни сложности

### Базовый уровень

- понимать разделение ролей client/server;
- строить простые request/response потоки;
- учитывать централизованную точку обработки.

### Средний уровень

- проектировать stateless [API](../../../glossary.md#abbr-005) и горизонтальное масштабирование;
- применять кэш и балансировку;
- выделять BFF/API gateway слой.

### Продвинутый уровень

- строить multi-tier клиент-серверные платформы;
- управлять [SLA](../../../glossary.md#abbr-079), rate limit и деградацией;
- эволюционировать модель в microservices/event-driven.

## Базовая схема

```kroki-plantuml
@startuml
actor Client
rectangle "Server API" as S
database "DB" as DB
Client --> S : request
S --> DB : query
S --> Client : response
@enduml
```

## Плюсы

- простая ментальная модель;
- быстрый старт разработки;
- понятное разграничение ответственности.

## Минусы

- риск единой точки отказа на сервере;
- ограниченная масштабируемость без дополнительных слоев;
- tight coupling при плохом [API](../../../glossary.md#abbr-005)-контракте.

## Когда выбирать

- web/mobile приложения с ясным backend;
- ограниченное число клиентов и предсказуемая нагрузка;
- ранние стадии продукта.

## Типичные ошибки

- stateful сервер без стратегии масштабирования;
- отсутствие rate limiting и retries;
- слабая версия API-контрактов.
## Стандарты и источники

- [RFC](../../../glossary.md#abbr-072) 9110 [HTTP](../../../glossary.md#abbr-038) Semantics.
- [REST](../../../glossary.md#abbr-071) API design best practices.
