# Клиент-серверная архитектура

Клиент-сервер — базовая модель взаимодействия, где клиент инициирует запрос, а сервер обрабатывает и возвращает результат.

## Уровни сложности

### Базовый уровень

- понимать разделение ролей client/server;
- строить простые request/response потоки;
- учитывать централизованную точку обработки.

### Средний уровень

- проектировать stateless API и горизонтальное масштабирование;
- применять кэш и балансировку;
- выделять BFF/API gateway слой.

### Продвинутый уровень

- строить multi-tier клиент-серверные платформы;
- управлять SLA, rate limit и деградацией;
- эволюционировать модель в microservices/event-driven.

## Базовая схема

```kroki-plantuml
@startuml
actor Client
rectangle "Server API" as S
database "DB" as DB
Client --> S : request
S --> DB : query
S --> Client : response
@enduml
```

## Плюсы

- простая ментальная модель;
- быстрый старт разработки;
- понятное разграничение ответственности.

## Минусы

- риск единой точки отказа на сервере;
- ограниченная масштабируемость без дополнительных слоев;
- tight coupling при плохом API-контракте.

## Когда выбирать

- web/mobile приложения с ясным backend;
- ограниченное число клиентов и предсказуемая нагрузка;
- ранние стадии продукта.

## Типичные ошибки

- stateful сервер без стратегии масштабирования;
- отсутствие rate limiting и retries;
- слабая версия API-контрактов.

## Контрольные вопросы

1. Какие риски SPOF есть в текущем client-server дизайне?
2. Какие endpoints должны быть stateless в первую очередь?
3. Где нужен кэш между клиентом и сервером?
4. Когда пора переходить к более сложной архитектуре?

## Чек-лист самопроверки

- API-контракты формализованы;
- стратегия масштабирования определена;
- базовые resilience-паттерны внедрены;
- метрики latency/error rate мониторятся;
- есть plan эволюции архитектуры.

## Стандарты и источники

- RFC 9110 HTTP Semantics.
- REST API design best practices.
