# Нормальные формы

Страница показывает практический путь от "сырой" таблицы к 1NF, 2NF, 3NF и BCNF, а также где уместны 4NF/5NF и обратная денормализация.

## Уровни сложности

### Базовый

- переход от неатомарных данных к 1NF и 2NF;
- выявление базовых аномалий вставки/обновления.

### Средний

- декомпозиция до 3NF/BCNF;
- оценка влияния нормализации на запросы и сопровождение.

### Продвинутый

- применение 4NF/5NF для специализированных доменов;
- обратная денормализация в OLAP и контроль согласованности витрин.

## Исходный пример

Таблица `orders_raw`:

| order_id | customer_name | customer_phones | product_ids | product_prices | manager |
| --- | --- | --- | --- | --- | --- |
| 1001 | Ivan Petrov | +7..., +7... | A1,B2 | 120,90 | M-01 |

Проблемы:

- множественные значения в одном поле;
- дублирование цен и клиента;
- риск аномалий обновления.

## 1NF

Правило: атомарные значения, без списков в ячейке.

Результат:

- отдельные строки по товарным позициям;
- телефоны в отдельную таблицу `customer_phone`.

## 2NF

Правило: нет частичных зависимостей от части составного ключа.

Пример:

- в `order_items(order_id, line_no, product_id, product_name, product_price)`
- `product_name` и `product_price` зависят от `product_id`, а не от полного ключа.

Решение:

- вынести `products(product_id, product_name, product_price)`.

## 3NF

Правило: убрать транзитивные зависимости.

Пример:

- в `orders(order_id, customer_id, customer_segment, discount_rule)`
- `discount_rule` зависит от `customer_segment`, а не напрямую от `order_id`.

Решение:

- `customer_segments(segment_id, discount_rule)`.

## BCNF

Усиление 3NF: любой детерминант должен быть кандидатом в ключ.

Пример кейса:

- `room, course -> instructor` и `instructor -> room` может нарушать BCNF.

## 4NF и 5NF (когда нужны)

- 4NF: устраняет мультизначные зависимости (редко для обычного OLTP, но полезно в сложных доменах каталога).
- 5NF: устраняет join dependencies (высокая сложность, чаще академические/специализированные кейсы).

## Денормализация для OLAP

Когда оправдано:

- тяжелая аналитика и повторяющиеся отчеты;
- latency чтения важнее минимального дублирования.

Подход:

- star schema;
- materialized views;
- агрегаты по периодам/сегментам.

## Влияние на производительность

| Решение | Плюс | Минус |
| --- | --- | --- |
| Нормализация | лучше целостность, меньше дублирование | больше join |
| Денормализация | быстрее чтение отчетов | сложнее поддерживать консистентность |

## Типовые ошибки

- доводить OLTP до чрезмерно глубоких нормальных форм без практической пользы;
- денормализовать в transactional core;
- не документировать зависимость витрин от первичных таблиц.

## Практические рекомендации

1. Для OLTP ориентир — 3NF/BCNF, если нет обратных требований.
2. Для BI используйте денормализацию в отдельном аналитическом слое.
3. Вводите data quality тесты на дубли и несогласованность.
4. Фиксируйте rationale каждого шага нормализации.
## Стандарты и источники

- Codd normalization overview: <https://en.wikipedia.org/wiki/Database_normalization>
- Date, C. J. Database Design and Relational Theory: <https://www.oreilly.com/library/view/database-design-and/9781491941164/>
