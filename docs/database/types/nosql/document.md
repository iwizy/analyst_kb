# Документоориентированные базы данных

Документные БД оптимальны для предметных областей с вариативной структурой сущностей и быстрыми изменениями модели.

## Уровни сложности

### Базовый

- понимать структуру документа и коллекции;
- выбирать embedded vs referenced модель.

### Средний

- проектировать индексы для nested полей;
- управлять согласованностью и транзакциями по нескольким документам.

### Продвинутый

- строить шардирование под ключ доступа;
- мигрировать из реляционной модели без потери качества данных.

## Когда выбирать document store

| Сценарий | Почему document |
| --- | --- |
| Каталог e-commerce | атрибуты товаров сильно отличаются по категориям |
| Пользовательские профили | динамическая структура предпочтений и настроек |
| CMS/контент | вариативные блоки и вложенные структуры |

## Пример документа

```json
{
  "productId": "SKU-1001",
  "title": "Кофемашина X",
  "category": "home_appliances",
  "price": 18990,
  "attributes": {
    "pressureBar": 15,
    "waterTankMl": 1200,
    "color": "black"
  },
  "availability": {
    "warehouse": "msk-01",
    "qty": 42
  },
  "updatedAt": "2026-02-10T09:15:00Z"
}
```

## Примеры запросов

```javascript
// MongoDB: фильтр + сортировка + ограничение
 db.products.find(
   { category: "home_appliances", "availability.qty": { $gt: 0 } },
   { title: 1, price: 1, attributes: 1 }
 ).sort({ price: 1 }).limit(20)
```

```javascript
// Агрегация
 db.products.aggregate([
   { $match: { category: "home_appliances" } },
   { $group: { _id: "$attributes.color", avgPrice: { $avg: "$price" } } },
   { $sort: { avgPrice: -1 } }
 ])
```

## Индексация

| Тип индекса | Когда использовать |
| --- | --- |
| Single-field | частый фильтр по одному полю |
| Compound | фильтр + сортировка по устойчивому pattern |
| Multikey | массивы и вложенные структуры |
| Text | полнотекстовый поиск внутри документов |
| TTL | автоудаление временных данных |

Пример:

```javascript
db.products.createIndex({ category: 1, price: 1 })
db.products.createIndex({ "availability.qty": 1 })
```

## ACID/BASE и целостность

- атомарность по одному документу обычно гарантируется;
- multi-document транзакции доступны, но дороже по latency;
- eventual consistency часто применяют для вторичных read моделей.

Практики целостности:

- version field + optimistic locking;
- idempotent upsert (`_id` или natural key);
- outbox pattern для интеграций.

## Безопасность

- TLS между клиентом и кластером;
- role-based access c минимальными правами;
- шифрование at-rest;
- маскирование чувствительных полей (PII/PCI) и аудит.

## Миграция из реляционной БД

1. Выбрать bounded context с наибольшей вариативностью схемы.
2. Спроектировать JSON-модель под read-path.
3. Настроить CDC/dual-write и валидацию консистентности.
4. Постепенно переключить чтение, затем запись.

## Типовые ошибки

- копировать реляционную нормализованную схему "как есть";
- хранить слишком большие документы без учета update frequency;
- избыточное вложение, которое усложняет выборки и обновления;
- отсутствие стратегии миграции схемы версий документов.

## Практические рекомендации

1. Моделируйте "по запросам", а не только по сущностям.
2. Документируйте контракт документа и versioning policy.
3. Проводите нагрузочный тест на критичных агрегациях.
4. Держите политику архивации/TTL для старых документов.

## Контрольные вопросы

1. Какие read-path сценарии определяют структуру документа?
2. Где нужны multi-document транзакции, а где нет?
3. Как происходит эволюция схемы документа между версиями?
4. Как вы валидируете консистентность после миграции?

## Чек-лист самопроверки

- выбраны ключи и индексная стратегия под реальные запросы;
- описаны правила целостности и версия схемы;
- реализована стратегия миграции и rollback;
- настроены RBAC, audit и шифрование;
- нагрузочные тесты подтверждают SLA.

## Стандарты и источники

- MongoDB docs: <https://www.mongodb.com/docs/>
- Couchbase docs: <https://docs.couchbase.com/>
- JSON Schema: <https://json-schema.org/>
