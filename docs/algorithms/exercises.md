# Задачи для самопроверки

Набор упражнений для закрепления курса по алгоритмам и структурам данных.

## Базовый уровень

1. Для массива из 20 элементов сравните линейный и бинарный поиск. Какие условия нужны, чтобы бинарный поиск был корректен?
1. Есть список заказов с полями `priority` и `created_at`. Какую сортировку и почему вы выберете для стабильной выдачи?
1. Оцените сложность псевдокода:

```text
for i in 1..n:
  for j in 1..n:
    doWork()
```

## Средний уровень

1. Нужно находить кратчайший путь между складами в сети дорог с весами (время в минутах). Какой алгоритм выбрать и почему?
1. Система хранит 10 млн пользователей и делает lookup по `email` 3000 раз в секунду. Какая структура данных подходит и какие риски у нее есть?
1. Есть глубокая иерархия категорий (до 8 уровней). Когда рекурсивный обход будет безопасен, а когда лучше перейти на итеративный?

## Продвинутый уровень

1. Для транзакционной системы предложите выбор между AVL и B-tree для индекса. Обоснуйте с учетом in-memory и disk-backed сценариев.
1. В quick sort вы наблюдаете деградацию до `O(n^2)` на почти отсортированных данных. Какие меры можно применить?
1. Постройте оценку сложности для pipeline:

```text
- фильтрация n записей
- сортировка оставшихся k записей
- бинарный поиск m раз по отсортированному набору
```

Выразите общую сложность через `n`, `k`, `m`.

## Практический мини-кейс

Сервис доставки:

- 100 000 активных заказов,
- маршруты между 700 точками,
- SLA ответа API: 200 мс (p95).

Задание:

1. Выберите структуры данных для lookup, очереди и маршрутизации.
1. Укажите критичные алгоритмы и их сложность.
1. Предложите 3 нефункциональных требования к производительности.

## Как проверять себя

- всегда формулируйте вход/выход алгоритма;
- называйте ожидаемую сложность по времени и памяти;
- фиксируйте ограничения и допущения (отсортированность, размер, тип данных).
