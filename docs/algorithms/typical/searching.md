# Алгоритмы поиска

Поиск — центральная операция в прикладных системах: от lookup в кэше до полнотекстового поиска и matching шаблонов.

## Уровни сложности

### Базовый

- линейный и бинарный поиск;
- условия применимости бинарного поиска;
- оценка `O(n)` и `O(log n)`.

### Средний

- поиск в хеш-таблицах и сбалансированных деревьях;
- обходы деревьев: pre/in/post/level;
- выбор структуры под профиль запросов.

### Продвинутый

- строковый поиск KMP/Boyer-Moore/Rabin-Karp;
- оценка коллизий и false positives;
- выбор алгоритма по длине шаблона и алфавиту.

## Линейный и бинарный поиск

### Линейный поиск

```text
linear_search(a, x):
  for i in 0..len(a)-1:
    if a[i] == x: return i
  return -1
```

- Время: `O(n)`
- Память: `O(1)`

### Бинарный поиск

```text
binary_search(a, x):
  l = 0; r = len(a)-1
  while l <= r:
    m = l + (r-l)//2
    if a[m] == x: return m
    if a[m] < x: l = m + 1
    else: r = m - 1
  return -1
```

- Требование: массив отсортирован.
- Время: `O(log n)`

## Поиск в хеш-таблицах

| Техника | Идея | Сложность |
| --- | --- | --- |
| Цепочки | bucket содержит список пар | O(1) среднее, O(n) худшее |
| Открытая адресация | probing в таблице | O(1) среднее, O(n) худшее |

- Важные параметры: load factor, качество hash-функции, resize strategy.

## Поиск в деревьях

### Обходы

```text
preorder(node): visit, left, right
inorder(node): left, visit, right
postorder(node): left, right, visit
levelorder(root): BFS через очередь
```

- Для BST inorder дает отсортированную последовательность.
- Поиск в сбалансированном BST: `O(log n)`.

## Поиск по шаблону в строках

### KMP (идея)

- Строит `prefix-function` (`lps`) для шаблона.
- Не возвращается назад по тексту лишний раз.
- Время: `O(n + m)`.

```text
kmp_search(text, pattern):
  lps = build_lps(pattern)
  i = 0; j = 0
  while i < n:
    if text[i] == pattern[j]: i++, j++
    if j == m: match at i-m; j = lps[j-1]
    else if i < n and text[i] != pattern[j]:
      if j != 0: j = lps[j-1]
      else: i++
```

### Boyer-Moore (идея)

- Сравнивает с конца шаблона.
- Использует bad-character / good-suffix эвристики.
- Часто быстрее на практике для больших алфавитов.

### Rabin-Karp (идея)

- Hash окна текста + hash шаблона.
- Среднее `O(n + m)`, худшее `O(nm)` при коллизиях.
- Подходит для множественного поиска шаблонов.

## Мини-реализации на языках (бинарный поиск)

### Python

```python
def bsearch(a, x):
    l, r = 0, len(a) - 1
    while l <= r:
        m = (l + r) // 2
        if a[m] == x:
            return m
        if a[m] < x:
            l = m + 1
        else:
            r = m - 1
    return -1
```

### Java

```java
int bsearch(int[] a, int x) {
    int l = 0, r = a.length - 1;
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (a[m] == x) return m;
        if (a[m] < x) l = m + 1; else r = m - 1;
    }
    return -1;
}
```

### C++

```cpp
auto it = std::lower_bound(v.begin(), v.end(), x);
bool found = (it != v.end() && *it == x);
```

## Плюсы и минусы подходов

| Подход | Плюсы | Минусы |
| --- | --- | --- |
| Линейный | простота, без предподготовки | медленный на больших данных |
| Бинарный | быстрый, логарифмический | нужен sorted input |
| Hash lookup | очень быстрый в среднем | коллизии, нет порядка |
| Деревья | порядок + поиск | сложнее реализация и overhead |
| KMP/BM/RK | эффективный string matching | выше сложность внедрения |

## Типичные ошибки

- бинарный поиск по неотсортированным данным;
- overflow midpoint (в старых реализациях);
- игнорирование коллизий hash;
- выбор RK без контроля качества hash.

## Контрольные вопросы

1. Когда линейный поиск лучше бинарного на практике?
2. Почему hash-таблица может деградировать до O(n)?
3. В чем отличие KMP от Boyer-Moore по стратегии сдвига?
4. Для каких данных лучше использовать BST вместо hash-map?

## Задачи для самопроверки

1. Реализуйте бинарный поиск первого вхождения элемента.
2. Сравните KMP и встроенный `find` на длинных логах.
3. Для каталога товаров выберите: hash, BST или B-tree — обоснуйте.
4. Реализуйте Rabin-Karp для поиска нескольких шаблонов.

## Источники и дальнейшее изучение

- CLRS, главы 11, 12, 32.
- Knuth-Morris-Pratt original paper.
- Boyer-Moore original paper.
