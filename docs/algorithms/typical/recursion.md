# Рекурсия и итерация

Рекурсия и итерация - два способа решать одну задачу. Для аналитика важно понимать, где рекурсия повышает читаемость, а где безопаснее и дешевле итеративный подход.

## Базовые определения

- Рекурсия: функция вызывает сама себя на меньшей подзадаче.
- Итерация: повторение через цикл (`for`, `while`) и явное состояние.

## Сравнение подходов

| Критерий | Рекурсия | Итерация |
| --- | --- | --- |
| Читаемость | часто выше для деревьев/графов | выше для линейных проходов |
| Память | стек вызовов `O(depth)` | обычно `O(1)` или контролируемая |
| Риск переполнения стека | есть | минимальный |
| Отладка | сложнее при большой глубине | проще шаг за шагом |

## Псевдокод: факториал

### Рекурсивно

```text
factorial(n):
  if n <= 1:
    return 1
  return n * factorial(n - 1)
```

### Итеративно

```text
factorialIter(n):
  result = 1
  for i from 2 to n:
    result = result * i
  return result
```

## Псевдокод: обход дерева

### Рекурсивный DFS

```text
dfs(node):
  if node is null:
    return
  process(node)
  dfs(node.left)
  dfs(node.right)
```

### Итеративный DFS через стек

```text
dfsIter(root):
  if root is null: return
  stack = [root]
  while stack not empty:
    node = pop(stack)
    process(node)
    if node.right exists: push(node.right)
    if node.left exists: push(node.left)
```

## Бизнес-сценарии

- Рекурсия: расчет иерархии категорий каталога, обход дерева согласований.
- Итерация: обработка транзакционного потока, массовая валидация записей.

## Практические правила

1. Если глубина неизвестна и может быть большой, чаще выбирайте итерацию.
1. Если структура естественно древовидная и глубина контролируема, рекурсия допустима.
1. В критичных по latency частях проверяйте профилирование обоих подходов.

## Самопроверка

1. Почему рекурсия удобна для дерева, но рискованна для очень длинного списка?
1. Как заменить рекурсию на цикл и стек в DFS?
1. Какие NFR стоит добавить для глубоких рекурсивных вызовов?
