# Практические сценарии применения алгоритмов
Страница связывает алгоритмы и структуры данных с прикладными задачами системного анализа: выбор маршрута, антифрод, ранжирование, дедупликация и планирование.

## Уровни сложности

### Базовый уровень

- сопоставлять задачу и класс алгоритма;
- выбирать структуру данных под профиль операций;
- оценивать порядок сложности на уровне Big-O.

### Средний уровень

- учитывать ограничения по latency, памяти и объему данных;
- сравнивать несколько подходов с явным trade-off;
- аргументировать выбор на уровне требований [NFR](../glossary.md#abbr-053).

### Продвинутый уровень

- проектировать гибридные решения (exact + heuristic);
- учитывать деградацию на пиках нагрузки;
- формировать план измерений (benchmark + observability).

## Как выбирать алгоритм в проекте

| Шаг | Вопрос |
| --- | --- |
| 1 | Какой тип входных данных и их размер? |
| 2 | Нужен точный или приближенный результат? |
| 3 | Что критичнее: время или память? |
| 4 | Какие ограничения по [SLA](../glossary.md#abbr-079)? |
| 5 | Можно ли предварительно сортировать/индексировать данные? |

## Кейс 1. Логистика: построение маршрутов

### Задача

Найти оптимальный путь доставки с учетом времени и стоимости.

### Подход

- граф дорог: вершины — точки, ребра — маршруты;
- Dijkstra для неотрицательных весов;
- A* при наличии хорошей эвристики расстояния.

| Алгоритм | Когда использовать | Сложность (типично) |
| --- | --- | --- |
| Dijkstra | точный shortest path без отрицательных весов | O((V+E) log V) |
| A* | нужен быстрый практический ответ | зависит от эвристики, часто быстрее Dijkstra |

## Кейс 2. E-commerce: рекомендации похожих товаров

### Задача

Быстро находить похожие карточки по множеству признаков.

### Подход

- precompute индексов/эмбеддингов;
- поиск top-k через heap/priority queue;
- approximate nearest neighbors для больших каталогов.

Практический trade-off: точность рекомендаций против latency выдачи.

## Кейс 3. Fintech: антифрод в онлайне

### Задача

Оценивать риск транзакции в пределах нескольких сотен миллисекунд.

### Подход

- hash map для быстрых lookup по blacklist/whitelist;
- decision tree для rule-based фильтров;
- графовые эвристики для цепочек подозрительных переводов.

### Типичные ошибки

- слишком тяжелая модель в online-контуре без fallback;
- отсутствие разделения online/offline вычислений;
- игнорирование worst-case при пиковом [RPS](../glossary.md#abbr-075).

## Кейс 4. Госуслуги: дедупликация заявлений

### Задача

Определять дубли заявлений и потенциальные конфликты по данным.

### Подход

- сортировка + линейный проход для точных дублей;
- hash-based fingerprint для быстрых совпадений;
- дополнительно string matching (например, для ФИО/адресов) на fuzzy-уровне.

## Матрица выбора по профилю задачи

| Профиль задачи | Рекомендуемые классы алгоритмов |
| --- | --- |
| Поиск в отсортированных данных | бинарный поиск |
| Поиск в неструктурированном потоке | хеш-таблица + фильтры |
| Иерархические данные | деревья/обходы DFS/BFS |
| Оптимизация под ограничение | динамическое программирование |
| Быстрый "достаточно хороший" результат | жадные/эвристические |

## Мини-шаблон фиксации выбора

| Поле | Пример |
| --- | --- |
| Бизнес-сценарий | online-маршрутизация курьера |
| Входные данные | граф из 80k вершин и 240k ребер |
| Ограничения | p95 <= 300 ms, память <= 1 GB |
| Кандидаты | Dijkstra, A* |
| Итоговое решение | A* с эвристикой расстояния + fallback на Dijkstra |
| Риски | ухудшение качества эвристики на новых регионах |

## Связанные материалы

- [Введение в раздел алгоритмов](index.md)
- [Сложность и O-нотация](complexity-big-o.md)
- [Структуры данных](data-structures.md)
- [Алгоритмы поиска](typical/searching.md)
- [Графы и деревья](typical/graphs-and-binary-trees.md)
- [Анализ и выбор алгоритмов](analysis-and-selection.md)

## Источники

- CLRS, Introduction to Algorithms.
- Skiena, The Algorithm Design Manual.
- MIT OpenCourseWare Algorithms: <https://ocw.mit.edu/>
