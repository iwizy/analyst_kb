# Динамическое программирование

> Глоссарий терминов и сокращений: [Открыть](../glossary.md)


Динамическое программирование (DP) решает задачи с перекрывающимися подзадачами и оптимальной подструктурой, сохраняя промежуточные результаты.

## Уровни сложности

### Базовый

- понимать идею memoization и tabulation;
- отличать DP от полного перебора;
- решать классические задачи (Fibonacci, coin change).

### Средний

- строить рекуррентные формулы;
- выбирать top-down или bottom-up;
- восстанавливать ответ из таблицы.

### Продвинутый

- оптимизировать память и время (rolling arrays, monotonic queues);
- распознавать скрытые DP-постановки в бизнес-задачах;
- комбинировать DP с графами и жадными эвристиками.

## Как распознать DP-задачу

- есть повторяющиеся подзадачи;
- решение состоит из оптимальных решений подзадач;
- можно сформулировать состояние и переход;
- brute-force экспоненциальный, но можно кэшировать.

## Top-down vs Bottom-up

| Подход | Плюсы | Минусы |
| --- | --- | --- |
| Top-down (memoization) | проще начать от рекурсии | overhead рекурсии |
| Bottom-up (tabulation) | предсказуемая память/время | сложнее формулировка порядка заполнения |

## Fibonacci: рекурсия vs DP

```text
fib_td(n):
  if n <= 1: return n
  if memo[n] exists: return memo[n]
  memo[n] = fib_td(n-1) + fib_td(n-2)
  return memo[n]
```

- Наивная рекурсия: `O(2^n)`
- DP: `O(n)` time, `O(n)` space

## 0/1 Knapsack

Состояние: `dp[i][w]` — максимальная ценность из первых `i` предметов при вместимости `w`.

Рекуррентность:

`dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])`

```text
for i in 1..n:
  for w in 0..W:
    dp[i][w] = dp[i-1][w]
    if weight[i] <= w:
      dp[i][w] = max(dp[i][w], dp[i-1][w-weight[i]] + value[i])
```

- Сложность: `O(nW)`

## Coin Change (минимум монет)

```text
dp[0] = 0
for x in 1..amount:
  dp[x] = INF
  for c in coins:
    if x-c >= 0:
      dp[x] = min(dp[x], dp[x-c] + 1)
```

- Сложность: `O(amount * |coins|)`

## LCS (Longest Common Subsequence)

```text
if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1
else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

- Сложность: `O(nm)`.
- Применение: diff, сравнение версий, био-информатика.

## Partition Problem

- Цель: можно ли разбить множество на две части равной суммы.
- Сводится к subset-sum на `target = total/2`.
- Сложность псевдополиномиальная `O(n * target)`.

## Плюсы и минусы DP

| Плюсы | Минусы |
| --- | --- |
| превращает экспоненту в полином | может требовать много памяти |
| дает точный оптимум | не всегда легко увидеть состояние |
| хорошо формализуется | риск ошибок в индексах и переходах |

## Типичные ошибки

- неверное определение состояния;
- некорректный базовый случай;
- перепутанный порядок заполнения таблицы;
- выход за границы массива DP.
## Задачи для самопроверки

1. Реализуйте Fibonacci top-down и bottom-up, сравните время.
2. Решите 0/1 knapsack для 20 предметов.
3. Найдите LCS для двух строк длиной 100.
4. Для задачи partition предложите оптимизацию памяти.

## Источники и дальнейшее изучение

- CLRS, Dynamic Programming chapter.
- Skiena, DP patterns.
- MIT OCW DP lectures.
