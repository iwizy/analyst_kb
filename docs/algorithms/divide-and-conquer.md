# Разделяй и властвуй

Подход Divide & Conquer разбивает задачу на подзадачи, решает их рекурсивно и объединяет результат.

## Уровни сложности

### Базовый

- понимать шаблон divide -> conquer -> combine;
- применять его к сортировкам;
- читать рекуррентные соотношения.

### Средний

- использовать мастер-теорему для оценки сложности;
- сравнивать D&C с DP и greedy;
- выбирать подход для численных и матричных задач.

### Продвинутый

- применять к большим вычислениям и параллелизации;
- оптимизировать рекурсивные вызовы;
- анализировать cache complexity.

## Общий шаблон

```text
solve(problem P):
  if P small: return direct_solution(P)
  split P into P1..Pk
  solve each Pi recursively
  return combine(results of Pi)
```

## Примеры

### Merge sort

- Делит массив пополам, сортирует и сливает.
- `T(n) = 2T(n/2) + O(n)` -> `O(n log n)`.

### Quicksort

- Делит по pivot.
- Среднее `O(n log n)`, худшее `O(n^2)`.

### Максимальная подпоследовательность (divide variant)

- Ищем максимум в левой, правой и пересекающей середину части.
- Сложность `O(n log n)`.

### Умножение Карацубы

- Снижает сложность умножения больших чисел.
- `T(n)=3T(n/2)+O(n)` -> `O(n^log2(3))`.

### [Алгоритм](../glossary.md#term-004) Страссена

- Для умножения матриц: 7 умножений подматриц вместо 8.
- Сложность примерно `O(n^2.807)`.

## Мастер-теорема (кратко)

Для `T(n) = aT(n/b) + f(n)`:

- Case 1: `f(n)` меньше `n^(log_b a)` -> `Theta(n^(log_b a))`
- Case 2: порядка того же -> `Theta(n^(log_b a) log n)`
- Case 3: больше -> `Theta(f(n))` (при regularity)

## Про решето Эратосфена

Решето — важный алгоритм теории чисел, но это не классический divide & conquer. Для него мастер-теорема неприменима напрямую.

- Сложность решета: `O(n log log n)`.
- Память: `O(n)`.
- Подробнее см. [Теория чисел](advanced/number-theory.md).

## Плюсы и минусы

| Плюсы | Минусы |
| --- | --- |
| часто снижает сложность по сравнению с наивным подходом | рекурсивный overhead |
| естественно параллелится | сложнее отладка объединения результатов |
| подходит для больших задач | риск stack overflow без оптимизаций |

## Типичные ошибки

- неправильный base case;
- неверное combine-правило;
- несбалансированное деление подзадач;
- неверный анализ рекуррентности.
## Задачи для самопроверки

1. Выведите рекуррентность merge sort и решите ее.
2. Реализуйте quicksort с random pivot.
3. Сравните классическое и карацуба-умножение на больших числах.
4. Объясните, почему решето не анализируется мастер-теоремой напрямую.

## Источники и дальнейшее изучение

- CLRS, Recurrences and Divide-and-Conquer.
- Akra-Bazzi theorem notes.
- Sedgewick, quicksort/mergesort analysis.
