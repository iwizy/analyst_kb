# Жадные алгоритмы

Жадный подход строит решение шаг за шагом, выбирая локально лучший вариант в надежде получить глобальный оптимум.

## Уровни сложности

### Базовый

- понимать идею локального выбора;
- различать greedy и DP;
- знать базовые greedy-задачи.

### Средний

- проверять условия применимости greedy;
- строить контрпримеры, где greedy ломается;
- доказывать оптимальность через exchange argument.

### Продвинутый

- комбинировать greedy с структурами данных (heap/DSU);
- применять в крупных оптимизационных пайплайнах;
- использовать greedy как приближение для NP-трудных задач.

## Greedy vs Dynamic Programming

| Критерий | Greedy | DP |
| --- | --- | --- |
| Решение | локальный выбор | полный учет состояний |
| Скорость | обычно быстрее | обычно медленнее |
| Гарантия оптимума | не всегда | чаще есть при корректной постановке |
| Сложность реализации | ниже | выше |

## Классические примеры

### Activity Selection

```text
sort activities by finish_time
pick first
for each next activity:
  if start >= finish(last_picked): pick
```

- Сложность: `O(n log n)`.

### Coin Change (каноническая система)

- В системах типа `{1, 5, 10, 25}` greedy работает.
- Контрпример: `{1, 3, 4}` для суммы `6`: greedy дает `4+1+1`, оптимум `3+3`.

### Huffman Coding

```text
put all frequencies into min-heap
while heap size > 1:
  a = extract_min()
  b = extract_min()
  merge node(a,b)
  insert merged node back
```

- Сложность: `O(n log n)`.
- Применение: сжатие данных.

### MST (Kruskal/Prim)

- Оба жадные и дают оптимальный остов при корректных условиях.

## Плюсы и минусы

| Плюсы | Минусы |
| --- | --- |
| быстрые и понятные решения | локальный оптимум не всегда глобальный |
| малый memory overhead | нужен формальный proof применимости |
| хорошо работают в online-сценариях | легко ошибиться в критерии выбора |

## Типичные ошибки

- применение greedy без доказательства корректности;
- игнорирование контрпримеров;
- неверный критерий сортировки/приоритета;
- отсутствие проверки edge cases.
## Задачи для самопроверки

1. Найдите максимальное число непересекающихся интервалов.
2. Постройте Huffman-код для заданных частот.
3. Придумайте контрпример для некорректного greedy-критерия.
4. Сравните greedy и DP для задачи coin change.

## Источники и дальнейшее изучение

- CLRS, Greedy Algorithms chapter.
- Kleinberg & Tardos, *Algorithm Design*.
