# Сложность алгоритмов и O-нотация

O-нотация (Big O) показывает, как растут затраты алгоритма при увеличении
объема входных данных. Для аналитика это инструмент оценки масштабируемости до
реализации.

## Почему это важно

- помогает оценивать риск деградации при росте нагрузки;
- позволяет обосновывать NFR по времени отклика и ресурсам;
- упрощает выбор между альтернативными решениями.

## Базовые классы сложности

| Сложность | Как растет время | Типовой пример |
| --- | --- | --- |
| `O(1)` | почти не зависит от `n` | доступ по индексу в массиве |
| `O(log n)` | растет медленно | бинарный поиск |
| `O(n)` | линейно | один проход по списку |
| `O(n log n)` | умеренно | эффективные сортировки |
| `O(n^2)` | быстро | двойной цикл по коллекции |
| `O(2^n)` | взрывной рост | полный перебор подмножеств |
| `O(n!)` | крайне быстро | перебор всех перестановок |

## Временная и пространственная сложность

- Временная сложность: сколько операций выполняет алгоритм.
- Пространственная сложность: сколько дополнительной памяти он использует.

Обе метрики важны. Иногда быстрый алгоритм требует больше памяти, и наоборот.

## Наглядный пример выбора

Задача: искать значения в коллекции много раз.

- Вариант 1: список + линейный поиск `O(n)`.
- Вариант 2: хеш-таблица (`set`/`dict`) + поиск `O(1)` в среднем.

```python
ids = [101, 205, 310, 412]
lookup = set(ids)

# Поиск в списке: O(n)
exists_in_list = 310 in ids

# Поиск в set: O(1) в среднем
exists_in_set = 310 in lookup
```

Если поисков много, второй вариант обычно значительно выгоднее.

## Как применять в требованиях

1. Фиксируйте профиль нагрузки (объем, частота, пики).
1. Для критичных операций задавайте целевую сложность.
1. Уточняйте ограничения по памяти и времени ответа.
1. Проверяйте фактическую сложность на тестовых данных.

## Типичные ошибки

- сравнение алгоритмов без одинаковых входных условий;
- игнорирование худшего случая и пиковых нагрузок;
- выбор "самого быстрого" алгоритма без учета памяти и простоты поддержки.

## Чек-лист качества

- Для ключевых операций указаны целевые границы производительности.
- Понятны допущения по входным данным.
- Выбранный алгоритм масштабируется под ожидаемый рост `n`.
