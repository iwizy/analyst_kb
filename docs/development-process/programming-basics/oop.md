# ООП для системного аналитика

ООП помогает описывать систему через сущности и их поведение. Для аналитика это практический инструмент: он позволяет структурировать требования и заранее видеть влияние изменений.

## Уровни сложности

### Базовый уровень

- понимать классы, объекты, методы, поля;
- различать инкапсуляцию, наследование, полиморфизм;
- читать простые class-диаграммы.

### Средний уровень

- связывать доменные объекты с требованиями;
- распознавать нарушения SRP и чрезмерную связанность;
- использовать интерфейсы для стабильных контрактов.

### Продвинутый уровень

- обсуждать DDD-агрегаты и границы контекстов;
- выбирать паттерны (Factory, Strategy, Observer) под задачу;
- учитывать расширяемость и тестируемость при описании требований.

## Базовая модель предметной области

```kroki-plantuml
skinparam monochrome true
class Order {
  +id: UUID
  +status: OrderStatus
  +createPayment()
}
class PaymentService {
  +authorize(orderId)
}
class NotificationService {
  +sendOrderEvent(orderId)
}
Order --> PaymentService
Order --> NotificationService
```

## Пример формулировки требования через ООП-подход

Плохо: "Система должна быстро уведомлять пользователя".  
Лучше: "После перехода `Order.status` в `PAID` сервис уведомлений вызывает `sendOrderEvent` не позднее 30 секунд".

## Частые ошибки

- смешение доменной и инфраструктурной логики в одном классе;
- слишком глубокая иерархия наследования;
- публичные поля без контроля инвариантов.

## Практические рекомендации

- одно бизнес-правило -> один явный владелец в модели;
- требование должно указывать, какой объект отвечает за изменение состояния;
- изменения в терминах статусов и событий проще тестировать и трассировать.

## Чек-лист самопроверки

- классы отражают предметную область, а не структуру БД;
- инварианты домена описаны явно;
- ответственность объектов не пересекается;
- AC можно проверить через состояние объекта и его события.

## Контрольные вопросы

1. Как определить, что класс делает слишком много (SRP нарушен)?
2. Когда лучше использовать композицию, а не наследование?
3. Как связать требования и class-диаграмму без потери смысла?

## Источники

- Fowler, *UML Distilled*.
- Evans, *Domain-Driven Design*.
- Martin, *Clean Architecture*.
